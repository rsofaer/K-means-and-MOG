p;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; K-means and Gaussian Mixture estimation with EM
;; Yann LeCun, April 2004, November 2005.

(libload "libimage/image-io")
(libload "image-tiles")
(libload "gaussian")

;; choose a tile file by uncommenting 
;; one of the following lines

;; (setq *image-file* "boat.png")
;; (setq *image-file* "buildings.png")
;; (setq *image-file* "bird.png")
(setq *image-file* "airplane.png")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; make tile file and load the tiles 
;; into global variable matrix "data".
(de load-data () 
  (image-to-tiles *image-file* "tiles.mat")
  (setq data (load-matrix "tiles.mat")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; This function takes an NxM matrix "x" containing
;; N data vectors of dimension M, and a KxM matrix "m"
;; which on input contains K initial prototype vectors. 
;; The function runs the K-means algorithm on the data until 
;; convergence. Upon completion, "m" contains the K prototypes
;; calculated by K-means.
(de k-means (x m convergence)
  (let ((converged ())
        (r (int-matrix (idx-dim x 0))));; ri is what prototype xi is assigned to
    (while (not converged)
      ;; Assign vectors to prototypes
      (idx-bloop ((tile x) (assignment r))
        (assignment (closest-prototype-index tile m)))
      ;; Recompute prototypes (checking for convergence)
      ;; Compute new prototypes
      (let ((new-m (double-matrix (idx-dim m 0) (idx-dim m 1)))
            (counters (int-matrix (idx-dim m 0))))
        ;; Add vectors to prototypes while incrementing counters
        (idx-gloop ((tile x)(assignment r)(i))
          ((select counters 0 (assignment)) (+ ((select counters 0 (assignment))) 1)); Increment counter
          ;(print (concat "assigning tile: " (str i) " to prototype: " (str (assignment)) ".  New counter: " (str (counters (assignment)))))
          (idx-add tile (select new-m 0 (assignment)) (select new-m 0 (assignment))))
        ;; Divide prototypes by counters
        (setq converged t)
        (idx-gloop ((p new-m)(old-p m)(i))
            (when (not (= 0 (counters i)))
              (idx-dotm0 p ((double-matrix) (/ (counters i))) p)
              )
            ;; Check for convergence
            (when (> ((idx-sqrdist p old-p)) convergence) (setq converged ())))
        (idx-copy new-m m)))
    m
    ))

;; Find the index in m of the vector in m closest to x
(de closest-prototype-index (x m)
    (let ((closest-index 0)
           (min-dist ((idx-sqrdist x (select m 0 0)))))
      (idx-gloop ((p m)(i))
        (let ((cur-dist ((idx-sqrdist p x))))
         (when (< cur-dist min-dist)
           (setq min-dist cur-dist)
           (setq closest-index i)
          )))
      closest-index))

(de closest-prototype (x m)
  (select m 0 (closest-prototype-index x m)))

;; Initialize the prototype vectors for k-means
(de pick-prototypes (input-set n-prototypes)
  (let ((prototypes (double-matrix n-prototypes 
                                  (idx-dim input-set 1)))
        (indicies ()))
    (while (< (length indicies) n-prototypes)
      (let ((new-i (rand 0 (idx-dim input-set 0))))
        (when (not (member new-i indicies))
          (setq indicies (nconc1 indicies new-i)))))
    (idx-gloop ((v prototypes)(c))
       (let ((i (nth c indicies)))
         (idx-copy (select input-set 0 i) v) 
         ))
    prototypes))

;; Calculate the mean-squared error 
;; for a dataset (x)
;; and a set of prototypes (m)
(de mean-squared-error (x m)
  (let ((total-error 0))
    (idx-bloop ((tile x))
      (setq total-error 
        (+ total-error (idx-sqrdist tile (closest-prototype tile m)))))
    (/ total-error (idx-dim x 0))))

(de compressed-tiles (input n-prototypes)
  (let ((prototypes (pick-prototypes input n-prototypes))
        (output (idx-copy input)))
        (k-means input prototypes 0.00001)
        (idx-bloop ((x output))
          (idx-copy (closest-prototype x prototypes) x))
        (list output prototypes)
    ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; create an array of k Gaussians of dimension n
(de make-aray-of-gaussians (k n)
  (let ((g (array k)))
    (idx-bloop ((g g)) (g (new gaussian n)))
    g))


;; This function run EM on a gaussian mixture model
;; with K components.  "x" is an NxM matrix "x" containing
;; N data vectors of dimension M, "g" is an array of Gaussian 
;; objects, and "w" is K-dimensional vector containing
;; the initial mixture weights. On output, "g", and "w" will 
;; contain the updated Gaussians, and mixture weights of the
;; mixture of gaussians. The function returns the
;; negative log-likelihood of the data given the model.
(de mog-em (x g w)
  (error "you must implement this function")
  (let* ((k (idx-dim g 0))
	 (n (idx-dim x 0))
	 (r (matrix n k))
	 (neg-log-likelihood 0)
	 (converged t))
    (while (not converged)
      (mog-e x g w r)
      (mog-m x g w r)
      (setq neg-log-likelihood (mog-nll x g w))
      (setq converged (you-must-put-some-code-here)))
    neg-log-likelihood))


;; This is the E-step of EM
;; "r" is the matrix of responsabilities.
(de mog-e (x g w r) 
  (error "you must implement this function")
  ())

;; This is the M-step of EM
;; "r" is the matrix of responsabilities.
(de mog-m (x g w r) 
  (error "you must implement this function")
  ())

;; Return the negative log-likelihood of the data in x
;; given the Gaussian mixture models in g and the
;; weights w.
(de mog-nll (x g w)
  (error "you must implement this function")
  ())

(load-data)

;(setq prototypes (pick-prototypes data 7))
;(k-means data prototypes 0.00001)
